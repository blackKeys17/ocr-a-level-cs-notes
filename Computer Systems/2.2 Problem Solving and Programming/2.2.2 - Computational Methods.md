***
## Section (d)

### Divide and conquer
- These types of algorithms can be separated into **3 stages**:
  - Divide
  - Conquer
  - Merge
- In the **divide** stage, the problem is split into **smaller subproblems**
- In the **conquer** stage, the smallest subproblems are **solved individually**
- In the **merge** stage, the solutions to the subproblems are **recombined** together to form a final solution

#### Binary Search
- Binary search can be considered to be a **divide and conquer** algorithm
- However, this algorithm doesn't really **merge** solutions to subproblems, and instead *discards* them
- The **original problem** of finding a value in a sorted list can be reduced or **divided** by looking at the item in the middle of the list:
  - If the item is the target, then we are done
  - Otherwise, depending on whether the target is smaller or larger than this item, we can either choose to only look at the top half of the list or the bottom half
  - This can be repeated until either the target is found in the list, or we are left with a sublist of length 1, then it doesn't exist in the list

#### Merge sort and quicksort
- Both of these sorting algorithms are **divide and conquer**
- The problems of sorting the original list is **divided** into the task of sorting 2 sublists
- The original list is broken down recursively until the sublists are of length 1, which are trivially sorted (and **conquered**)
- The sorted sublists are **merged** together in both algorithms, until the original list has been sorted

#### Evaluation
- Very complex problems can be **simplified greatly** when their size is halfed at every stage
- This means that a lot of divide and conquer algorithms are **fast**
- However, as they are usually implemented **recursively**, they can be difficult to **debug** and **trace** 
